# Idempotency in Payment Processing

This document explains the idempotency implementation in this Payment API, including semantics, edge cases, and storage strategy.

## What is Idempotency?

**Idempotency** ensures that performing the same operation multiple times produces the same result as performing it once. In payment processing, this is critical to prevent:

- Double-charging customers
- Creating duplicate payment records
- Inconsistent account balances
- Financial reconciliation issues

## Idempotency Key Requirements

Every payment request **must** include an `idempotencyKey` field:

```json
{
  "amount": 100.00,
  "currency": "USD",
  "idempotencyKey": "unique-request-id-123"
}
```

### Key Characteristics

| Requirement | Description |
|-------------|-------------|
| **Required** | Cannot be empty or null |
| **Unique** | Must be unique per payment intent |
| **Immutable** | Once used, always maps to the same payment |
| **Client-generated** | Generated by the API consumer |

## Semantic Behavior

### First Request
1. Client sends payment request with new idempotency key
2. System checks if key exists in database
3. Key not found → process payment
4. Store payment with idempotency key
5. Return created payment

### Subsequent Requests (Same Key)
1. Client sends payment request with existing idempotency key
2. System checks if key exists in database
3. Key found → return existing payment
4. **No new payment is created**
5. Original payment data is returned

### Important: Request Payload Mismatch

If a request uses an existing idempotency key but with **different** payload (amount, currency):

```json
// First request
{"amount": 100.00, "currency": "USD", "idempotencyKey": "key-123"}
// Returns: Payment for $100 USD

// Second request (same key, different amount)
{"amount": 200.00, "currency": "EUR", "idempotencyKey": "key-123"}  
// Returns: ORIGINAL payment for $100 USD (not $200 EUR!)
```

**The system returns the original payment, not the new values.** This is by design - the idempotency key represents the original intent.

## Concurrency Handling

### Race Condition Prevention

When multiple requests with the same idempotency key arrive simultaneously:

```
Request A (key-123) ──┐
                      ├── Only ONE payment is created
Request B (key-123) ──┘
```

This is achieved through:

1. **In-memory locking** (`ConcurrentDictionary<string, SemaphoreSlim>`)
   - First request acquires lock for the idempotency key
   - Second request waits for lock
   - After first completes, second finds existing payment

2. **Database unique constraint** (backup protection)
   - Unique index on `IdempotencyKey` column
   - Catches any edge cases that bypass in-memory lock

### Thread-Safety Guarantees

```csharp
// Simplified lock mechanism
var lockObj = _locks.GetOrAdd(idempotencyKey, _ => new SemaphoreSlim(1, 1));
await lockObj.WaitAsync();
try
{
    var existing = await _repo.GetByIdempotencyKeyAsync(key);
    if (existing != null) return existing;
    // ... process and store payment
}
finally
{
    lockObj.Release();
}
```

## Storage Strategy

### Database Schema

```sql
CREATE TABLE Payments (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    Amount DECIMAL NOT NULL,
    Currency VARCHAR(3) NOT NULL,
    Status INT NOT NULL,
    CreatedAt DATETIME NOT NULL,
    IdempotencyKey VARCHAR(255) NOT NULL
);

CREATE UNIQUE INDEX IX_Payments_IdempotencyKey ON Payments(IdempotencyKey);
```

### Why Store in Main Table?

We store idempotency keys directly in the `Payments` table rather than a separate table because:

1. **Simplicity** - No join queries needed
2. **Atomicity** - Payment and key are stored in single transaction
3. **Performance** - Single table lookup for idempotency check
4. **Consistency** - Key and payment cannot be out of sync

### Alternative: Separate Idempotency Table

For more complex scenarios, consider a dedicated table:

```sql
CREATE TABLE IdempotencyKeys (
    Key VARCHAR(255) PRIMARY KEY,
    ResourceType VARCHAR(50),
    ResourceId UNIQUEIDENTIFIER,
    RequestHash VARCHAR(64),  -- For payload validation
    CreatedAt DATETIME,
    ExpiresAt DATETIME        -- For key expiration
);
```

## Edge Cases

### 1. Key Expiration (Not Implemented)

In production, consider expiring old keys:
- After 24-48 hours
- Based on payment finality
- With cleanup jobs

### 2. Failed Payment with Same Key

If initial payment fails:
```
Request 1 (key-123) → Gateway fails → Payment stored with Status=Failed
Request 2 (key-123) → Returns the FAILED payment (not reprocessed)
```

**Current behavior**: Returns original failed payment. Consider implementing retry window for failures.

### 3. Partial Failures

If payment fails mid-process:
- Before DB write: No payment exists, can retry with same key
- After DB write: Payment exists, returns existing record

### 4. Distributed Systems

For multi-instance deployments, replace in-memory locks with:
- Redis distributed locks
- Database advisory locks
- Consensus-based locking (Consul, etcd)

## Best Practices

### DO ✅

- Generate keys client-side before request
- Use UUIDs or meaningful composites (`order-{id}-payment`)
- Include key in logging (for traceability)
- Retry with same key on network failures

### DON'T ❌

- Reuse keys for different payment intents
- Generate keys from timestamps alone
- Use sequential/predictable keys
- Skip idempotency key in retry logic

## Testing Idempotency

```csharp
[Fact]
public async Task SameIdempotencyKey_ShouldReturnSamePayment()
{
    var key = "test-key-123";
    
    var response1 = await CreatePayment(amount: 100, key: key);
    var response2 = await CreatePayment(amount: 200, key: key);
    
    Assert.Equal(response1.Id, response2.Id);
    Assert.Equal(100, response2.Amount); // Original amount!
}
```

See `tests/Payments.IntegrationTests` for more examples.
